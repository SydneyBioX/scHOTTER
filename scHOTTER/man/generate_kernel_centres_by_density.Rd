% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generate_kernel_centres.R
\name{generate_kernel_centres_by_density}
\alias{generate_kernel_centres_by_density}
\title{Generate approximate kernel centres on a grid to hit a target span}
\usage{
generate_kernel_centres_by_density(coords, span = NULL)
}
\arguments{
\item{coords}{A numeric matrix or data frame with two columns giving x,y
coordinates of points (rows are points). Column order is \code{c(x, y)}.}

\item{span}{Optional numeric in \eqn{(0, 1]}. Interpreted as the target
proportion of data points per kernel. If \code{NULL}, a heuristic default
\eqn{13 / n_{\mathrm{points}}} is used (capped at \code{0.5}); a message is emitted.}
}
\value{
A numeric matrix with two columns \code{c("x","y")} giving kernel
centre coordinates.
}
\description{
Places kernel centres on a regular grid over the 2D coordinate bounds so that,
on average, each kernel would contain roughly \code{span * n_points} data points
(under a uniform-density approximation). This is useful for building spatial
kernels whose size scales with the observed point density.
}
\details{
Let \eqn{n} be the number of points and \eqn{A} the area of the bounding box
of \code{coords}. We approximate point density by \eqn{n / A} and choose a
square kernel with side length \eqn{\sqrt{(\mathrm{target\_n}) / (n/A)}} where
\eqn{\mathrm{target\_n} = \lceil \mathrm{span} \times n \rceil}. Grid spacing
equals this side length, producing \eqn{n_x \times n_y} centres that tile the
bounding box.
}
\examples{
set.seed(1)
coords <- cbind(runif(100, 0, 10), runif(100, 0, 5))
centres <- generate_kernel_centres_by_density(coords, span = 0.1)
dim(centres)       # number of centres
head(centres)

}
