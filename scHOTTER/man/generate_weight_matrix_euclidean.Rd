% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generate_weight_matrix.R
\name{generate_weight_matrix_euclidean}
\alias{generate_weight_matrix_euclidean}
\title{Build a point-by-kernel weight matrix (Euclidean neighborhoods)}
\usage{
generate_weight_matrix_euclidean(
  coords,
  grid_centres,
  span = NULL,
  type = c("block", "gaussian")
)
}
\arguments{
\item{coords}{Numeric matrix or data frame with two columns \code{c(x, y)} giving
point coordinates (rows are points).}

\item{grid_centres}{Numeric matrix or data frame with two columns \code{c(x, y)}
giving kernel-centre coordinates (e.g., from
\code{\link{generate_kernel_centres_by_density}}).}

\item{span}{Optional numeric in \eqn{(0, 1]}. Target proportion of points to associate
with each kernel (used to choose \code{k = ceiling(span * n_points)} neighbors).
If \code{NULL}, defaults to \eqn{13 / n_{\mathrm{points}}} (capped at 0.5).}

\item{type}{Character; either \code{"block"} or \code{"gaussian"}.}
}
\value{
A \code{Matrix::dgCMatrix} sparse matrix \code{W} with rownames taken from
\code{coords} (if present) and column names \code{"k_1", ..., "k_m"} for m kernels.
}
\description{
Computes a sparse \eqn{n_{\mathrm{points}} \times n_{\mathrm{kernels}}} weight
matrix \code{W} using Euclidean distance from each kernel centre to each point.
Two schemes are supported:
\itemize{
\item \strong{block}: weights are 1 for neighbors within the search radius, 0 otherwise.
\item \strong{gaussian}: weights are \eqn{\exp\{ -d^2 / (2\sigma^2) \}}, with
\eqn{\sigma = \mathrm{gap}/2}, where \code{gap} is the minimum grid spacing,
and \eqn{d} is the distance from the kernel centre to the point of interest.
}
}
\details{
\strong{Grid spacing (gap).} The search radius is set to the smallest spacing between
unique \code{x}- or \code{y}-coordinates of \code{grid_centres}. If only a single
centre exists on an axis, we fall back to a coarse spacing based on the data range.

\strong{Neighbor search.} We query up to \eqn{k = \lceil \mathrm{span}\, n\rceil}
nearest neighbors per kernel centre using \pkg{RANN}. If your \pkg{RANN} version
does not support radius-restricted search, a standard k-NN query still works; the
\code{"block"} scheme then effectively selects the returned neighbors.
}
\examples{
set.seed(1)
coords <- cbind(runif(100, 0, 10), runif(100, 0, 5))
centres <- generate_kernel_centres_by_density(coords, span = 0.1)
Wb <- generate_weight_matrix_euclidean(coords, centres, span = 0.1, type = "block")
Wg <- generate_weight_matrix_euclidean(coords, centres, span = 0.1, type = "gaussian")
dim(Wb); Matrix::nnzero(Wb)

}
\seealso{
\code{\link{generate_kernel_centres_by_density}}
}
