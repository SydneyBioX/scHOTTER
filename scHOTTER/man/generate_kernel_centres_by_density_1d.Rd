% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kernel_centres_1d.R
\name{generate_kernel_centres_by_density_1d}
\alias{generate_kernel_centres_by_density_1d}
\title{Generate kernel centres for 1D (trajectory) coordinates}
\usage{
generate_kernel_centres_by_density_1d(coords, span = NULL)
}
\arguments{
\item{coords}{Numeric matrix or data frame of coordinates with \code{n} rows
(points) and \code{p} columns (axes). Exactly one column must have
non-zero range; other columns may be constant (or nearly so). The nonzero
coordinate may correspond to a pseudotimepoint or similar.}

\item{span}{Optional numeric in \eqn{(0,1]}. Target proportion of points per
kernel. If \code{NULL}, a heuristic default \eqn{13 / n} is used (capped at
\code{0.5}); a message is emitted.}
}
\value{
A numeric matrix with the same columns as \code{coords}. The varying
axis is filled with an evenly spaced grid over its range; constant axes are
filled with their (NA-robust) medians. Row count equals the number of
kernel centres.
}
\description{
For data where exactly one coordinate dimension varies across points
(i.e. an effectively 1D trajectory embedded in \eqn{\mathbb{R}^p}),
place kernel centres along the varying axis so that, on average, each kernel
collects about \code{span * n_points} points (under a uniform-density
approximation). Non-varying dimensions are fixed at their column medians.
}
\details{
Let \eqn{L} be the range length of the varying axis and \eqn{n} the number of
points. We approximate the 1D density by \eqn{n / L}, target the number of
points per kernel as \eqn{\lceil \mathrm{span} \cdot n \rceil}, set the kernel
length to \eqn{\mathrm{target\_n} / (n/L)}, and place
\eqn{\lceil L / \mathrm{kernel\_len} \rceil} centres evenly over the axis.
}
\examples{
set.seed(1)
t  <- sort(runif(100, 0, 10))   # pseudotime
y0 <- rep(0, 100)               # constant second dim
centres <- generate_kernel_centres_by_density_1d(cbind(t, y0), span = 0.2)
head(centres)

}
