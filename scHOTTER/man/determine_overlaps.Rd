% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/overlaps.R
\name{determine_overlaps}
\alias{determine_overlaps}
\title{Determine overlapping kernels (share \eqn{\geq} 1 point)}
\usage{
determine_overlaps(membership_matrix)
}
\arguments{
\item{membership_matrix}{A 0/1 matrix (preferably \code{Matrix::dgCMatrix})
with rows = points and cols = kernels. You can obtain this via
\code{\link{generate_membership_matrix}}.}
}
\value{
A named list of length \eqn{k} (number of kernels). Element \code{[[i]]}
is a character vector of kernel names that overlap with kernel \code{i}
\strong{including itself}.
}
\description{
From a binary membership matrix \eqn{M} (\eqn{\text{points} \times \text{kernels}}), compute which
kernels overlap, where overlap means at least one shared point. Internally
uses \eqn{A = M^\top M}; \eqn{A_{ij} > 0} indicates that kernels \eqn{i} and \eqn{j}
share at least one point. This is an intermediate step required to determine
which kernels are "light" and shouldn't be considered in downstream analysis.
}
\examples{
# Minimal controlled example
M <- Matrix::sparseMatrix(i = c(1,2,2,3), j = c(1,1,2,2), x = 1,
                          dims = c(3,2), dimnames = list(NULL, c("k_1","k_2")))
determine_overlaps(M)

# Typical workflow
set.seed(1)
coords  <- cbind(runif(40), runif(40))
centres <- generate_kernel_centres_by_density(coords, span = 0.2)
W       <- generate_weight_matrix_euclidean(coords, centres, span = 0.2, type = "block")
Memb    <- generate_membership_matrix(W)
ovl     <- determine_overlaps(Memb)
str(ovl[1:2])

}
