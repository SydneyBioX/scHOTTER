% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipeline_1d.R
\name{scHOTTER_pipeline_1d}
\alias{scHOTTER_pipeline_1d}
\title{End-to-end pipeline (1D trajectory): local co-expression p-values}
\usage{
scHOTTER_pipeline_1d(
  expr,
  span = NULL,
  kernel_type = c("block", "gaussian"),
  fisher_transform = TRUE,
  drop_zero_weight = TRUE
)
}
\arguments{
\item{expr}{Numeric matrix (\eqn{\text{points} \times  \text{genes}}). Row names must encode coordinates.
Column names are gene symbols.}

\item{span}{Optional numeric in (0, 1]; target proportion of points per kernel.
If \code{NULL}, a heuristic \eqn{13/n} capped at 0.5 is used.}

\item{kernel_type}{\code{"block"} or \code{"gaussian"}; passed to
\code{\link{generate_weight_matrix_euclidean_1d}}.}

\item{fisher_transform}{Logical; apply Fisher \code{atanh} to local correlations
(default \code{TRUE}). Keep \code{TRUE} to match the null variance model.}

\item{drop_zero_weight}{Logical; restrict each kernelâ€™s computation to rows
with weight \code{> 0} for that kernel (default \code{TRUE}).}
}
\value{
A list with:
\itemize{
\item \code{p_values}: named numeric vector of p-values (one per gene pair).
\item \code{summary}: data.frame with columns \code{pair}, \code{s2}, \code{z}, \code{p}.
\item \code{intermediates}: a list containing
\code{coords}, \code{centres}, \code{weight_matrix_initial}, \code{membership},
\code{overlaps}, \code{light_kernels}, \code{weight_matrix}, \code{local_corr_matrix},
\code{neff}, \code{corr}, \code{sigma}, \code{expectation}, \code{variance},
\code{s2}, \code{z_scores}, \code{p_values}.
\item \code{params}: the input parameters actually used.
}
}
\description{
A 1D analogue of \code{scHOTTER_pipeline()} for trajectory-like data where
\emph{exactly one} coordinate axis varies across points. Row names of
\code{expr} must encode coordinates (e.g. "xxy", "x_y", "x,y" or "x y"). The varying
axis is used to place kernel centres and compute 1D weights; all subsequent
steps (local Fisher z, analytic null, Z, p) are identical to the 2D pipeline.
}
\examples{
set.seed(1)
n <- 80
t  <- sort(runif(n, 0, 10))
y0 <- rep(0, n)                           # constant second axis
coords <- cbind(t = t, y = y0)
rn <- apply(coords, 1, function(v) paste0(v[1], "_", v[2]))
expr <- cbind(g1 = rnorm(n), g2 = rnorm(n), g3 = rnorm(n))
rownames(expr) <- rn

out1d <- scHOTTER_pipeline_1d(expr, span = 0.2, kernel_type = "gaussian")
head(out1d$summary)

}
